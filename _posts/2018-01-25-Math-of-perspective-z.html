---
layout: post
title:  "Math of Perspective Z"
date:   2018-01-25 00:00:00 -0600
categories: jekyll update

javascript: "webgl_2"
---
<p>
    As I was learning about depth of field I realized that I would need to somehow obtain a value for how far away a pixel is from
    the camera in a post processing shader. After reading various articles about the how to compute this value, none 
    really showed how to derive it starting at the original equations, they just showed the end equation. So, I decided to derive it myself. 
    Below was my attempt and results, which basically simulate a linear z-buffer compared to the default non-linear one.</p>
    
    This is a standard row major perspective projection matrix: </p>
    <img src=" {{ "/textures/row_major_perspective.png" | absolute_url }} ">


    <p>Lets call the third row, third column value <b>A</b> and the fourth row, third column value <b>B</b>, <b>Ze</b> will be the z value 
        in eye space, <b>Zc and Wc</b> will be the z and w values in clip space, and <b>Zn</b> will be the z value in NDC space.</p>

        <p>
        If we transform a Vector in eye space with the components (x, y, z, 1) by this matrix then 
            <p><b>Zc = Ze * A + 1 * B and Wc = Ze * -1</b></p>
        What then gets written to the z-buffer is z in ndc space, or: <p><b>Zn = Zc / Wc</b></p>

        if <b>Wc</b> is just <b>-Ze</b> then the whole expression can be written as:

        <p><b> Zn = (Ze * A + B) / -Ze  </b></p>
        </p>

<p>
    In a post processing shader we can sample the z-buffer texture to get the value for <b>Zn</b>, we can also use the camera parameters to create the 
    values for <b>A</b> and <b>B</b>. now we can use the above equation to solve for <b>Ze</b>.

    <p>Lets start with multiplying both sides by <b>-Ze</b>, we now have <p><b>Zn * -Ze = Ze * A + B</b></p>

    Next lets also move <b>Ze * A</b> to the left side <p><b>Zn * -Ze - Ze * A = B</b></p>

    If we then factor out the <b>-Ze</b> we are left with <p><b>-Ze * (Zn + A) = B</b></p>

    Dividing both sides by <b>Zn + A results in</b> <p><b>-Ze = B / (Zn + A)</b></p>

    Finally multiply each side by -1 to get the equation <p><b>Ze = -(B / (Zn + A))</b></p>

    </p>

    To check the mapping and unmapping, lets take a look at an example, <b>N = 0.1</b> will be the near plane, <b>F = 256</b> will be the far plane, 
    and <b>Ze = -30</b> will be the eye space z value. Because OpenGL has Zn from -1 to 1, after Zn is computed, I scale it between 0 and 1 to simulate a valid
    texture value

    <hr>
    <p><b>A = -(256 + 0.1) / (256 - 0.1) = -256.1 / 255.9 = -1</b></p>
    <p><b>B = -(2 * 256 * 0.1) / (256 - 0.1) = -51.1 / 255.9 = -0.2</b></p>
    <p><b>Zc = -30 * -1 + -0.2 = 29.8</b></p>
    <p><b>Zn = 29.8 / 30 = 0.9933</b></p>
    <p><b>Zn = (0.9933 + 1) * 0.5 = 0.99665</b></p>

    <hr>

    <p>And now for the unmapping:</p>
    <hr>
    <p><b>Ze = (0.99665 * 2) - 1 = 0.9933</b></p>
    <p><b>Ze = -(-0.2 / (0.9933 - 1))</b></p>
    <p><b>Ze = -(-0.2 / -0.0067)</b></p>
    <p><b>Ze = -(29.85) = -29.85</b> (I skipped a little precision above)</p>
    <p></p>
    <hr>

    <p>
        

    </p>

    And there you have it, I believe the math checks out. Using the math above, here is a WebGL scene that computes the eye space z value 
    in the post processing shader, takes its absolute value, and then divides it by the far plane to get a value between 0 and 1. The results 
    appear more linear than the standard z-buffer, where it is very hard to even see anything unless you are very close to objects.
    These modes can be swapped between using the number keys 1 and 2, and 3 for the normal color rendering.
</p>

<canvas width="800" height="600" id='gl'></canvas>
